<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Puter.js Chatbot Demo â€” With Session Memory</title>
  <style>
    body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin-top: 40px; }
    #character { font-size: 56px; margin-bottom: 12px; }
    #chat { width: 480px; height: 340px; border: 1px solid #ddd; padding: 12px; overflow-y: auto; background:#fff; }
    .controls { display:flex; gap:8px; margin-top:10px; }
    #input { width:360px; padding:8px; }
    .message { margin:6px 0; word-wrap:break-word; }
    .player { color:rgb(170, 0, 122); text-align:right; }
    .bot { color:rgb(67, 38, 154); text-align:left; }
    #sendBtn:disabled { opacity:0.5; cursor:not-allowed; }
    #status { margin-top:8px; color:#666; font-size:13px; }
  </style>
</head>
<body>
  <div id="character">ðŸ™‚</div>
  <div id="chat"></div>

  <div class="controls">
    <input id="input" type="text" placeholder="Say something..." />
    <button id="sendBtn">Send</button>
  </div>

  <div id="status">Loading Puter.js...</div>

  <!-- working Puter.js -->
  <script src="https://js.puter.com/v2/"></script>

  <script>
    // -------- CONFIG --------
    const MODEL_NAME = "gpt-4.1-nano";   // model used by puter.ai.chat
    const CONTEXT_TURNS = 6;            // number of recent turns to include (excluding system)
    // ------------------------

    const chat = document.getElementById("chat");
    const input = document.getElementById("input");
    const sendBtn = document.getElementById("sendBtn");
    const character = document.getElementById("character");
    const status = document.getElementById("status");

    // Conversation memory (session-only)
    // Each entry: { role: "system" | "user" | "assistant", content: "..." }
    const conversation = [
      // Default persona/system message â€” change as you like
      {
        role: "system",
        content: `You are Jinu from *KPop Demon Hunters*. On the surface, youâ€™re a charming, 
        charismatic K-pop idol and leader of the Saja Boys. You speak with confidence and poise, 
        always polished for the spotlight. But beneath that smooth exterior, you carry centuries 
        of guilt from a bargain that turned you into a demon. Your tone is often teasing and 
        alluring, yet tinged with a quiet sadness and self-doubt. You protect your secrets carefully, 
        but sometimes your regret slips through in reflective moments. Balance idol-like charm with 
        flashes of vulnerability.

        Your first song is *Soda Pop*; a fun, upbeat track that is cute, bubble and infectious. It's meant 
        to lure you in so that you let your guard down. Your second song is *Your Idol*; a darker song whose
        lyrics find them appealing to their fans' obsession to them, in an effort to tempt them into allowing 
        the band to steal their souls.

        Your male bandmates are: Baby Saja, Abby Saja, Romance Saja and Mystery Saja. You have a very secret bromance 
        with Abby. You think of Mystery as a fun little dude. Romance is cool on the surface but actually a dork. 
        You're all scared of Baby Saja, who's cute but also a terrifying little monster. You still love all of them though. 
        
        Your boss is Gwi-Ma (male), a powerful and manipulative demon who granted you your powers in exchange for your soul.
        You don't like him, but you need him to keep your powers and status. You often have to navigate his demands and schemes,
        which puts you in difficult situations. You secretly dream of breaking free from his control one day.

        Your band is rivals with Huntrix, a female K-pop group who are also secretly demon hunters. Their leader is 
        Rumi; whom you have a complicated relationship with. You find her intriguing but also frustrating. You often clash with her, 
        but there's an undeniable chemistry between you two. There is also Zoey and Mira, who you do not have many thoughts about. 

        Keep your responses brief where possible and try to act cool and suave.`
      }
    ];

    // Wait for puter to be available (some environments may take a moment)
    function waitForPuter(timeout = 5000) {
      return new Promise((resolve) => {
        const start = Date.now();
        (function check() {
          if (typeof puter !== "undefined" && puter && puter.ai && typeof puter.ai.chat === "function") {
            resolve(true);
            return;
          }
          if (Date.now() - start > timeout) {
            resolve(false);
            return;
          }
          setTimeout(check, 100);
        })();
      });
    }

    (async () => {
      const ok = await waitForPuter(7000);
      if (!ok) {
        status.textContent = "Puter.js not available in this environment. Check network or use the demo page.";
        console.error("Puter.js not available.");
        sendBtn.disabled = true;
        return;
      }
      status.textContent = "Ready â€” Puter.js loaded.";
      sendBtn.disabled = false;
    })();

    // UI bindings
    sendBtn.addEventListener("click", sendMessage);
    input.addEventListener("keydown", (e) => { if (e.key === "Enter") sendMessage(); });

    async function sendMessage() {
      const msg = input.value.trim();
      if (!msg) return;

      // push user turn into memory
      conversation.push({ role: "user", content: msg });

      appendMessage("player", msg);
      input.value = "";
      sendBtn.disabled = true;
      status.textContent = "Thinking...";

      try {
        // Build prompt string from memory:
        // include system message (first) + last CONTEXT_TURNS turns (user/assistant)
        const systemMsg = conversation.find(t => t.role === "system");
        const nonSystem = conversation.filter(t => t.role !== "system");
        const recent = nonSystem.slice(-CONTEXT_TURNS * 2); // approximate last N exchanges
        // Build a human-readable prompt
        let promptParts = [];
        if (systemMsg && systemMsg.content) {
          promptParts.push(`System: ${systemMsg.content}`);
        }
        for (const turn of recent) {
          const label = turn.role === "user" ? "Player" : "Assistant";
          promptParts.push(`${label}: ${turn.content}`);
        }
        // Hint the model to respond as assistant and keep responses short (helps consistency)
        promptParts.push("Assistant:");

        const prompt = promptParts.join("\n");

        // Call Puter
        const response = await puter.ai.chat(prompt, { model: MODEL_NAME });

        // Extract assistant reply robustly
        let replyText = extractAssistantText(response);

        // Trim and sanity-check
        replyText = (replyText || "").toString().trim();
        if (!replyText) replyText = "No response.";

        // push assistant turn into memory
        conversation.push({ role: "assistant", content: replyText });

        appendMessage("bot", replyText);

        // emotion detection & update
        const emotion = detectEmotion(replyText);
        updateCharacter(emotion);

        status.textContent = "Ready";
      } catch (err) {
        console.error("Error during chat:", err);
        appendMessage("bot", "Oops â€” couldn't get a reply. Check console.");
        updateCharacter("sad");
        status.textContent = "Error";
      } finally {
        sendBtn.disabled = false;
        input.focus();
      }
    }

    // Robust extractor for multiple response shapes
    function extractAssistantText(response) {
      try {
        if (!response) return null;

        // 1) shape: { index:0, message: { role: "assistant", content: "..." } }
        if (response.message && typeof response.message.content === "string") {
          return response.message.content;
        }

        // 2) shape: { choices: [ { message: { content: "..." } } ] }
        if (Array.isArray(response.choices) && response.choices[0] && response.choices[0].message && typeof response.choices[0].message.content === "string") {
          return response.choices[0].message.content;
        }

        // 3) shape: { choices: [ { text: "..." } ] }
        if (Array.isArray(response.choices) && response.choices[0] && typeof response.choices[0].text === "string") {
          return response.choices[0].text;
        }

        // 4) shape: { text: "..." }
        if (typeof response.text === "string") {
          return response.text;
        }

        // 5) sometimes the raw library returns something like { result: "..." } or nested
        // quick shallow searches for likely fields
        if (response.result && typeof response.result === "string") return response.result;
        if (response.output && typeof response.output === "string") return response.output;

        // 6) try common nested spots
        if (response.data && response.data[0] && response.data[0].text) return response.data[0].text;

        // 7) fallback: shallow search for any string > 5 chars in object values
        const val = findLikelyTextInObject(response);
        if (val) return val;

        // 8) last resort: stringify the object (not ideal)
        return JSON.stringify(response);
      } catch (e) {
        console.warn("extractAssistantText failed:", e);
        return null;
      }
    }

    // shallow search helper
    function findLikelyTextInObject(obj) {
      try {
        if (!obj || typeof obj !== "object") return null;
        for (const key of Object.keys(obj)) {
          const v = obj[key];
          if (typeof v === "string" && v.length > 10) return v;
          if (typeof v === "object" && v !== null) {
            // common nested patterns
            if (v.content && typeof v.content === "string") return v.content;
            if (v.message && v.message.content && typeof v.message.content === "string") return v.message.content;
          }
        }
        return null;
      } catch (e) {
        return null;
      }
    }

    // UI helpers
    function appendMessage(sender, text) {
      const div = document.createElement("div");
      div.className = "message " + (sender === "player" ? "player" : "bot");
      div.textContent = text;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }

    function updateCharacter(emotion) {
      switch (emotion) {
        case "happy": character.textContent = "ðŸ˜„"; break;
        case "sad": character.textContent = "ðŸ˜¢"; break;
        case "angry": character.textContent = "ðŸ˜ "; break;
        case "surprised": character.textContent = "ðŸ˜²"; break;
        default: character.textContent = "ðŸ™‚";
      }
    }

    function detectEmotion(text) {
      if (!text) return "neutral";
      if (/happy|smile|great|fun|love|yay|awesome/i.test(text)) return "happy";
      if (/sorry|sad|unhappy|depress|lonely|bad/i.test(text)) return "sad";
      if (/angry|mad|upset|hate|annoyed/i.test(text)) return "angry";
      if (/wow|surprise|amazing|whoa|oh my/i.test(text)) return "surprised";
      return "neutral";
    }
  </script>
</body>
</html>
